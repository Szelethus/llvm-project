//==- ClangSAConfigsEmitter.cpp - Generate Clang SA config tables -*- C++ -*-
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This tablegen backend emits Clang Static Analyzer -analyzer-config tables.
//
//===----------------------------------------------------------------------===//

#include "TableGenBackends.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"
#include <map>
#include <string>

using namespace llvm;

using SortedRecords = llvm::StringMap<const Record *>;

static void printOptionFields(const Record *R, raw_ostream &OS,
                              bool IsDefaultValString) {
  OS << R->getName() << ","
     << "\"";
  OS.write_escaped(R->getValueAsString("Name")) << "\",\"";
  OS.write_escaped(R->getValueAsString("HelpText")) << "\",";
  StringRef DefaultVal = R->getValueAsString("DefaultVal");

  if (IsDefaultValString) {
    if (DefaultVal == "")
      OS << "\"\"";
    else
      OS << "\"" << DefaultVal << "\"";
  } else
    OS << DefaultVal;
}

static SortedRecords getSortedDerivedDefinitions(RecordKeeper &Records,
                                                 StringRef ClassName) {
  SortedRecords Ret;
  for (const Record *R : Records.getAllDerivedDefinitions(ClassName))
    Ret[R->getValueAsString("Name")] = R;
  return Ret;
}

static std::string getEnumName(const Record *R) {
  return R->getNameInitAsString() + "Kind";
}

void clang::EmitClangSAConfigs(RecordKeeper &Records, raw_ostream &OS) {

  OS << "// This file is automatically generated. Do not edit this file by "
        "hand.\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  // - TYPE: Type of the option in class AnalyzerOptions.
  // - FIELD_NAME: Name of the field in class AnalyzerOptions.
  // - CMDFLAG: Name of the flag to be specified on the command line. For
  //            specifics, check clang -cc1 -analyzer-config-help.
  // - HELPTEXT: Text displayed under -analyzer-config-help.
  // - DEFAULTVAL: Default value of the option if its not specified in the
  //               command line.
  OS << "\n"
        "#ifdef BOOLEAN_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "BooleanConfig")) {
    const Record *R = Pair.second;
    OS << "BOOLEAN_OPTION(bool,";
    printOptionFields(R, OS, /*IsDefaultValString*/false);
    OS << ")\n";
  }
  OS << "#endif // BOOLEAN_OPTIONS\n"
        "\n";

  // Emit integer options.
  //
  // INTEGER_OPTIONS(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  // Check the comments around BOOLEAN_OPTION for description of the parameters.
  OS << "\n"
        "#ifdef INTEGER_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "IntegerConfig")) {
    const Record *R = Pair.second;
    OS << "INTEGER_OPTION(int,";
    printOptionFields(R, OS, /*IsDefaultValString*/false);
    OS << ")\n";
  }
  OS << "#endif // INTEGER_OPTIONS\n"
        "\n";

  // Emit string options.
  //
  // STRING_OPTIONS(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  // Check the comments around BOOLEAN_OPTION for description of the parameters.
  OS << "\n"
        "#ifdef STRING_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "StringConfig")) {
    const Record *R = Pair.second;
    OS << "STRING_OPTION(StringRef,";
    printOptionFields(R, OS, /*IsDefaultValString*/true);
    OS << ")\n";
  }
  OS << "#endif // STRING_OPTIONS\n"
        "\n";

  // Emit enum options. These are string options can only take a select fe
  // values, and are parsed into enums.
  //
  // ENUM_OPTIONS(
  //   TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL, VALUES)
  //
  // Check the comments around BOOLEAN_OPTION for description of the first few
  // parameters.
  // - VALUES: A string that lists all options that can be specified on the
  //           command line. Each value is separated with a comma (its still one
  //           big string!). They correspond with enum values with the same
  //           index (see ENUMS below).
  OS << "\n"
        "#ifdef ENUM_OPTIONS\n";
  for (const auto &Pair : getSortedDerivedDefinitions(Records, "EnumConfig")) {
    const Record *R = Pair.second;
    OS << "ENUM_OPTION(" << getEnumName(R) << ",";
    printOptionFields(R, OS, /*IsDefaultValString*/true);
    OS << ',';
    if (!R->isValueUnset("Values")) {
      for (const Record *EnumVal : R->getValueAsListOfDefs("Values")) {
        OS << "\"";
        OS.write_escaped(EnumVal->getValueAsString("CmdFlag"));
        OS << ",\"";
      }
    }
    OS << ")\n";
  }
  OS << "#endif // ENUM_OPTIONS\n"
        "\n";

  // Emit enum classes corresponding with the enum options.
  //
  // enum class <option name>Kind {
  //   <first enum value> = 0,
  //   ...
  //   <nth enum value> = n - 1
  // };
  //
  // Enum values are equal with the index of the command line option in VALUES
  // in ENUM_OPTIONS.
  OS << "\n"
        "#ifdef ENUMS\n";
  for (const auto &Pair : getSortedDerivedDefinitions(Records, "EnumConfig")) {

    const Record *R = Pair.second;
    OS << "enum class " << getEnumName(R) << "{\n";
    int Counter = 0;
    for (const Record *EnumVal : R->getValueAsListOfDefs("Values")) {
      OS << "  ";
      OS.write_escaped(R->getValueAsString("EnumPrefix")) << '_';
      OS.write_escaped(EnumVal->getValueAsString("EnumName"))
          << " = " << Counter++;
      OS << ",\n";
    }
    OS << "}\n\n";
  }
  OS << "#endif // ENUMS\n"
        "\n";
}
