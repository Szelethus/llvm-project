//=- ClangSACheckersEmitter.cpp - Generate Clang SA checkers tables -*- C++ -*-
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This tablegen backend emits Clang Static Analyzer -analyzer-config tables.
//
//===----------------------------------------------------------------------===//

#include "TableGenBackends.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Record.h"
#include "llvm/TableGen/TableGenBackend.h"
#include <map>
#include <string>

using namespace llvm;

using SortedRecords = llvm::StringMap<const Record *>;

static void printOptionFields(const Record *R, raw_ostream &OS) {
  OS << R->getName() << ","
     << "\"";
  OS.write_escaped(R->getValueAsString("Name")) << "\",\"";
  OS.write_escaped(R->getValueAsString("HelpText"))
      << "\"," << R->getValueAsString("DefaultVal");
}

static SortedRecords getSortedDerivedDefinitions(RecordKeeper &Records,
                                                 StringRef ClassName) {
  SortedRecords Ret;
  for (const Record *R : Records.getAllDerivedDefinitions(ClassName))
    Ret[R->getValueAsString("Name")] = R;
  return Ret;
}

static std::string getEnumName(const Record *R) {
  return R->getNameInitAsString() + "Kind";
}

void clang::EmitClangSAConfigs(RecordKeeper &Records, raw_ostream &OS) {

  OS << "// This file is automatically generated. Do not edit this file by "
        "hand.\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  OS << "\n"
        "#ifdef BOOLEAN_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "BooleanConfig")) {
    const Record *R = Pair.second;
    OS << "BOOLEAN_OPTION(bool,";
    printOptionFields(R, OS);
    OS << ")\n";
  }
  OS << "#endif // BOOLEAN_OPTIONS\n"
        "\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  OS << "\n"
        "#ifdef INTEGER_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "IntegerConfig")) {
    const Record *R = Pair.second;
    OS << "INTEGER_OPTION(int,";
    printOptionFields(R, OS);
    OS << ")\n";
  }
  OS << "#endif // INTEGER_OPTIONS\n"
        "\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  OS << "\n"
        "#ifdef STRING_OPTIONS\n";
  for (const auto &Pair :
       getSortedDerivedDefinitions(Records, "StringConfig")) {
    const Record *R = Pair.second;
    OS << "STRING_OPTION(StringRef,";
    printOptionFields(R, OS);
    OS << ")\n";
  }
  OS << "#endif // STRING_OPTIONS\n"
        "\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  OS << "\n"
        "#ifdef ENUM_OPTIONS\n";
  for (const auto &Pair : getSortedDerivedDefinitions(Records, "EnumConfig")) {
    const Record *R = Pair.second;
    OS << "ENUM_OPTION(" << getEnumName(R) << ",";
    printOptionFields(R, OS);
    if (!R->isValueUnset("Values")) {
      for (const Record *EnumVal : R->getValueAsListOfDefs("Values")) {
        OS << "\"";
        OS.write_escaped(EnumVal->getValueAsString("CmdFlag"));
        OS << ",\"";
      }
    }
    OS << "\")\n";
  }
  OS << "#endif // ENUM_OPTIONS\n"
        "\n";

  // Emit boolean options.
  //
  // BOOLEAN_OPTION(TYPE, FIELD_NAME, CMDFLAG, HELPTEXT, DEFAULTVAL)
  OS << "\n"
        "#ifdef ENUMS\n";
  for (const auto &Pair : getSortedDerivedDefinitions(Records, "EnumConfig")) {

    const Record *R = Pair.second;
    OS << "enum class " << getEnumName(R) << "{\n";
    for (const Record *EnumVal : R->getValueAsListOfDefs("Values")) {
      OS << "  ";
      OS.write_escaped(R->getValueAsString("EnumPrefix")) << '_';
      OS.write_escaped(EnumVal->getValueAsString("EnumName"));
      OS << ",\n";
    }
    OS << "}\n\n";
  }
  OS << "#endif // ENUMS\n"
        "\n";
}
